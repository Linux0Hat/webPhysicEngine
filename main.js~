var canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
var TimeIndicator;
var objects;
var meterSize = 100; // number of pixel for make 1m
var gravityX = 0 * meterSize;
var gravityY = 0 * meterSize;

function Init() {
  console.log("Web Physic Engine by Linux_Hat dev-0.1");
  objects = {
    sun: {
      type: "circle",
      x: 400,
      y: 400,
      vx: 0,
      vy: 0,
      radius: 50,
      color: "#FF0000",
      mass: 10000000000000,
      freeze: true,
    },
    circle2: {
      type: "circle",
      x: 400,
      y: 100,
      vx: 700,
      vy: 0,
      radius: 20,
      color: "#0000FF",
      mass: 10,
      freeze: false,
    },
    circle3: {
      type: "circle",
      x: 600,
      y: 100,
      vx: 0,
      vy: -320,
      radius: 10,
      color: "#00FF00",
      mass: 5,
      freeze: false,
    },
  };
  TimeIndicator = new Date().getTime();
}

function drawObjects(objects) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (var key in objects) {
    var object = objects[key];

    if (object.type === "box") {
      ctx.beginPath();
      ctx.rect(object.x, object.y, object.width, object.height);
      ctx.fillStyle = object.color;
      ctx.fill();
      ctx.closePath();
    }

    if (object.type === "circle") {
      ctx.beginPath();
      ctx.arc(object.x, object.y, object.radius, 0, Math.PI * 2);
      ctx.fillStyle = object.color;
      ctx.fill();
      ctx.closePath();
    }
  }
}

function updateObjectsPosition(objects) {
  for (var key in objects) {
    var object = objects[key];

    var t = (new Date().getTime() - TimeIndicator) / 1000;

    object.x += object.vx * t;
    object.y += object.vy * t;
  }
}

function updateObjectsVelocity(objects) {
  for (var key in objects) {
    var object = objects[key];
    if (!object.freeze) {
      var t = (new Date().getTime() - TimeIndicator) / 1000;
      object.vx += gravityX * t;
      object.vy += gravityY * t;
    } else {
      object.vx = 0;
      object.vy = 0;
    }
  }
}

function checkObjectsCollisions(objects) {
  var ObjectsResults = [];

  for (var key in objects) {
    var ObjectResults = [];
    var object = objects[key];
    if (object.type == "circle") {
      for (var key_ in objects) {
        if (key != key_) {
          var object_ = objects[key_];
          if (object_.type == "circle") {
            var result =
              object.radius + object_.radius >
              Math.sqrt(
                (object.x - object_.x) ** 2 + (object.y - object_.y) ** 2
              );
            if (result) {
              ObjectResults.push(key_);
            }
          }
        }
      }
    }
    ObjectsResults.push({ key: key, ObjectResults: ObjectResults });
  }
  return ObjectsResults;
}

function collideObjects(collideList) {
  for (var key in collideList) {
    var object = objects[collideList[key]["key"]];
    for (var key_ in collideList[key]["ObjectResults"]) {
      var object_ = objects[collideList[key]["ObjectResults"][key_]];

      const deltaX = object_.x - object.x;
      const deltaY = object_.y - object.y;
      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      const overlap = object.radius + object_.radius - distance;

      if (overlap > 0) {
        if (!object.freeze) {
          const correctionRatio = overlap / distance;
          object.x -= deltaX * correctionRatio;
          object.y -= deltaY * correctionRatio;
        }

        const relativeVelocityX = object_.vx - object.vx;
        const relativeVelocityY = object_.vy - object.vy;

        const dotProduct =
          deltaX * relativeVelocityX + deltaY * relativeVelocityY;
        const impulse =
          (2 * dotProduct) / (distance * (object.mass + object_.mass));

        object.vx += (impulse * object_.mass * deltaX) / distance;
        object.vy += (impulse * object_.mass * deltaY) / distance;

        object_.vx -= (impulse * object.mass * deltaX) / distance;
        object_.vy -= (impulse * object.mass * deltaY) / distance;
      }
    }
  }
}

function gravityBetweenObjects(objects) {
  for (var key in objects) {
    var object = objects[key];
    for (var key_ in objects) {
      var object_ = objects[key_];
      if (
        key != key_ &&
        key_ in
          checkObjectsCollisions(objects)[Object.keys(objects).indexOf(key)][
            "ObjectResults"
          ] ===
          false
      ) {
        var d = Math.sqrt(
          (Math.abs(object.x - object_.x) + Math.abs(object.y - object_.y)) /
            meterSize
        );
        var G = 6.674e-11;
        var F = (G * (object.mass * object_.mass)) / (d * d);
        var a = Math.atan2(object_.y - object.y, object_.x - object.x);
        var t = (new Date().getTime() - TimeIndicator) / 1000;
        object.vx += F * t * Math.cos(a);
        object.vy += F * t * Math.sin(a);
      }
    }
  }
}

Init();

function Loop() {
  var fps = 1000 / (new Date().getTime() - TimeIndicator);
  document.getElementById("fps").innerText = fps.toFixed(2);
  gravityBetweenObjects(objects);
  collideObjects(checkObjectsCollisions(objects));
  updateObjectsVelocity(objects);
  updateObjectsPosition(objects);
  drawObjects(objects);
  TimeIndicator = new Date().getTime();
  requestAnimationFrame(Loop);
}

Loop();
